# 实现一个基础的模板引擎(其一)


如果了解浏览器的历史的话，应该知道最初浏览器原本主要是浏览在线文档的工具，而 html 在当时的定位更加类似与 markdown。如今，浏览器俨然发展成为一个应用的平台，应用的页面时根据数据渲染出来的，而 html 也并没有提供数据绑定的功能。于是自 html 开始制作交互应用之后，鲜见有人徒手写 html，基本上都是通过模板生成的。


在实现一个模板引擎之前，自然需要定义这个模板引擎的语法。咱们这个简单模板引擎主要实现 if 判断， loop 循环，和插入 js 代码三个功能。

* if 判断以  `<!-- if(cond) -->` 开始，以 `<!--finish-->` 结束，中间可以通过 `<!--else(cond)-->` 分割，而  `<!--else-->` 是 `<!--else(true)-->` 的简写
* loop 循环则以  `<!-- loop<value,index>(cond) -->` 开始其中 `<value,index>` 分别为当前循环对应的元素及索引，以  `<!-- end -->` 为结束。
* 通过 `{{ /* js code */ }}` 的方式，插入 js 代码

示例：
```html
    <template id="tpl">
        <div>
            <!--loop(new Array(times).fill(null))-->
            <ol>
                <!--loop<value,index>(list)-->
                <li>
                    <!--if(value.type === 'text')-->
                    <span>{{value.text}}</span>
                    <!--else(value.type === 'input')-->
                    <input type="text" value="{{value.value}}" />
                    <!--else-->
                    <b style="color:red">Error Value</b>
                    <!--end-->
                </li>
                <!--over-->
            </ol>
            <!--over-->
        </div>
    </template>
```


我们实现的这个模板引擎的解析器主要分为如下几个步骤。先通过一个词法分析器将字符串拆成一个一个单词，然后通过词法分析器将这个一串单词流变成一个词法分析树，之后优化词法树生成抽象语法树。最后将这个抽象语法树添加 render 方法，接受数据生成对应的 html 。接下来的主要内容就是做词法分析。


首先，我们定义一个基类 LexerNode，表示我们解析之后的节点。在 LexerNode 中，首先肯定需要的是当前节点对应的字符串，除此之外还可以添加一个 extra 属性表示在节点解析中产生的其他信息。词法分析的输入是模板字符串，输出是一个 LexerNode 的数组。


我们将 ` {{ js code }}` 视为一个单词，添加一个 LexerCodeNode 的派生类，，添加一个静态属性 match，为用于匹配的正则 `/(\{\{[\w|\W]+?\}\})/` ，在 `<span>{{value.text}}</span>` 中，content 即为 `{{value.text}}`，同时我们将 `value.text` 则保存在 `extra` 上，以方便之后的工作。


tip ：这里需要注意的是，以这种方式切分单词是一种取巧的做法。一个正经的词法解析，会将 `{{ js code }}` 拆分为 `{{`  `text` `}}` 三个单词，在之后的语法解析的过程中再把这几个词拼成一个节点。后者的最大好处在于更为友好的错误提示。譬如用户在写模板代码的时候，忘记添加结束符 `}}` ，以我们的方法这一段模板会直接匹配不上，退化为 text 而不会报任何错误。但是以后者的方式，则会解析出来并在语法解析式因不符合解析规则，报匹配结束符错误。


照葫芦画瓢，我们可以以相同的方式定义 LexerOverNode / LexerEndNode / LexerTextNode / LexerIfNode / LexerElseNode 。


将所有节点定义后，接下来就是将模板转换成对应节点了。这里我们借助了 js 的 split 方法。通过不断将模板进行截取，最终生成需要的节点。这里需要注意，其一是截取的优先级问题，譬如 LexerTextNode 包含所有的字符串定然是最后解析。其二在定义正则的时候，最外层需要一个括号，保证在截取时保留原来的字符串以转换成对应节点。


自此，我们的词法解析就完成了。写一个函数将不同的节点转换为不同颜色的 span ，测试一下我们解析的成果。


在开始语法分析之前，我们需要介绍一下 BNF 范式。形如 `progarm   =>  expr_list $$ `，每一个单独的符号表示一个语法元素，箭头则表示，左侧符号可以由右侧进一步拆分。一个可以拆分的符号被称为非终结符，用一个尖括号括起来。除此之外的终结符，则意味其仅存在与表达式的右侧。我们用 $$ 表达字符流的结束，用 ε 表示为空，那么我们的模板代码的语法可以表示成这样。


```javascript
/**
 * <progarm>  => <expr>  $$
 *            => $$

 * <expr>     => <expr> <expr>
 *            => text
 *            => code 
 *            => loop <expr> over
 *            => loop over
 *            => if <expr> <if_tail> 
 *            => if <if_tail>  
 * 
 * <if_tail>  => end
 *            => else <expr> <if_tail>
 *            => else <if_tail>
 */
```


program 表示整个模板的解构，也是我们解析的入口。 expr 指代的是一个表达式，它可以是 一个 text 节点，一个 code 节点 一个 if 结构，一个 loop 解构，或者多个表达形成的 list。一个 if 结构中可以有多个 else 节点。于是可以单独拆分为一个 if_tail 元素，以递归方式定义其结构。


显然这用 BNF 定义的结构是一个多叉树。在下一节中，我们将把上面的 BNF 表达式转化为真实的代码，将我们的单词数组转换称为这么一个多叉树。
