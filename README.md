# 实现一个基础的模板引擎(其三)


在上一节中，我们已经通过 parser 将其解析成一个树结构，但可惜的是因为种种原因，比如之前提到的左递归问题，这个树不能称为直接表示成我们代码逻辑的抽象语法树。它被称为语法分析树，需要进一步做转换。


在做这部分转换之前，我们先来看看我们的抽象语法树应该长什么样子。先定义一个基类 AstNode ，其包括一个 toHtml 方法，接受我们的绑定的数据对象，生成对应的 html 字符串。因为是树结构，有的节点能成为其他元素的父节点 ——  AstParentNode 其拥有一个 children 属性，是包含其子元素的数组，如果是以后序遍历的方式构造这个树的话，我们可以在构造函数内定义 children 的具体内容，不过我们这次是以线序遍历的方式进行构造，那么当构造当前节点的时候是不知道它有哪些子元素的，那我们添加一个 setChildren 方法用于对 children 属性的修改。至于为什么是先序遍历的方式，之后具体再说。


接着定义具体的 AstNode 类。最简单的是 AstHtmlNode , 其构造函数接收一个字符串，toHtml 方法直接返回就行。接下来是 AstTextNode，也是接受一个字符串，不过这个字符串是 js 代码，toHtml 则是执行这个代码返回结果，这里我们暂时不深究代码如何执行，仅仅设计树结构。之后是  AstLoopNode，它继承自 AstParentNode，构造函数不仅仅需要对应的 js 代码，而且还需要用户定义的 value/index 的字段名称。接下来是 AstIfNode ，用于判断，它除了对于 js 代码外，还需要一个 else 属性，设置判断为 fasle 的时候另外的一个分支，这了 else 属性可以为另外的一个 AstIfNode 节点，也可以为 null 代表没有下一个分支。最后，在定义一个 ParserRootNode，作为我们的根节点，其 toHtml 方法也很简单，把所有子元素节点 toHtml 方法累加就行。


设计完成后就是转换的过程。树结构的转换显然是需要进行树的遍历，而树的遍历一般用的是一个递归的过程。首先定义一个 dealParserNode 函数进行递归。这个函数第一个需要的参数显然是当前处理的语法分析树上的节点，如果还需要有其他的上下文参数，我们可以在后面加上。至于每次递归的返回结果，假如我们的语法分析树和抽象语法树是一一对应的关系，那么返回结果可以是一个抽象语法树的节点，显然我们目前的情况不是这样，比如像 exprList 节点，本身是可以对应多个抽象语法树节点的。所以，我们返回的是一个更加泛化的形式——互为兄弟节点的数组。分析树的结构在 BNF 中已经表示出来了，转换也很简单。如果当前是 ParserProgarmNode 那么对应的节点是 AstProgramNode，根据 BNF 可以看出来，ParserProgarmNode 的子节点只能是 ParserExprListNode ，于是我们递归调用 dealParserNode，将生成的数组作为 AstRootNode 的子节点。针对所有 ParserNode 都进行如此判断，最后就能得到我们需要的抽象语法树。


树结构有了，其实我们最后一步就是 js 代码完成 toHtml 方法了。动态执行 js 代码的方案，eval + with 现在已经不被推荐了，我们的方案则是 new function 的方式。可以在 mdn 中查到，new Function，接受多个参数，前面的参数代表这个函数的形参的名字，最后一个参数是函数体。后者，可以从解析的模板中获取，前者则需要从我们中的函数中来，后者则是从绑定的数据对象中来，对象上面每一个字段都表示一个参数。于是我们分别定义 Scope 和 Func 类，前者接受一个字符串数组表示函数对应的参数，后者则接受一个 scope 对象和函数体字符串，生成对应函数，scope 上有对应的 apply 方法，加载数据执行函数得出结果。于是，在生成 AstNode 之前需要知道有数据对象上有哪些字段，生成对应的 scope 对象，在生成 Ast 节点的时候还需要把这个 scope 带上。


慢着，还有个特殊节点，在我们 loop 节点中，还能声明新的字段，表示遍历时当前的变量和索引。这意味着在我们的 AstNode 上还能定义新的变量，而上级定义的新变量下级同样能够访问到。这类似与 js 的函数闭包，子函数能访问到上层函数中定义的变量。于是在 scope 上添加一个 extends 属性，用于继承原 scope 的基础上添加新的变量。于是上述的逐层传递的 globe，也会变成 parent。于是我们现在可以完成所有的 toHtml,并写个函数测试一下。
